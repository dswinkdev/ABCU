# ABCU Course Advising System
Reflection on Data Structures Projects

Purpose and Problem
--
In these projects, I addressed challenges related to managing and organizing data efficiently using data structures. Specifically:

In Project One, I analyzed the runtime complexity and memory usage of vectors, hash tables, and binary search trees to determine their efficiency in solving course data management problems.

In Project Two, I implemented a solution to sort and print a list of Computer Science courses in alphanumeric order using a binary search tree. This involved creating a menu-driven program that retrieves and organizes data for optimal usability.

The central problem was to select appropriate data structures and algorithms to store, search, and display course information efficiently while ensuring scalability and reliability.

Approach & Importance of Data Structures
--
I approached the problem by analyzing the strengths and weaknesses of each data structure:

Vectors offered simple implementations but lacked efficient searching for large datasets.

Hash Tables provided near-constant-time lookups but did not maintain a sorted order.

Binary Search Trees (BSTs) allowed for both sorted storage and efficient searching.

Understanding data structures is critical because they directly impact the performance and maintainability of software. Choosing the right structure for the task ensures the program runs efficiently even as data scales.

In Project Two, I implemented a binary search tree to store courses, sort them by their alphanumeric course numbers, and print the results in order. This demonstrated the importance of balancing efficiency and usability in real-world applications.

Overcoming Challenges
--
During the development process, I faced challenges with:

(1) Parsing Course Data: Ensuring the program correctly parsed input data and handled edge cases like missing prerequisites or formatting issues.

(2) Implementing the Binary Search Tree: Writing recursive functions for insertion, in-order traversal, and searching required careful debugging to ensure correctness.

(3) Balancing Runtime and Memory: Understanding the trade-offs for each data structure helped me select the most appropriate solution for specific tasks.

To overcome these roadblocks:

I used debugging tools and wrote test cases to validate the tree's operations.

I reviewed the runtime analysis for each structure to confirm that the binary search tree was the best choice.

Designing Software & Writing Better Programs
--
This project expanded my approach to designing software by emphasizing the importance of planning and analyzing trade-offs. I learned that:

Data-driven decisions about structures and algorithms improve program efficiency.

Modular design makes programs easier to maintain and adapt.

Understanding runtime complexities allows developers to anticipate performance bottlenecks.

Additionally, I focused on writing clean and readable code by:

(1) Organizing code into modular functions for clarity.

(2) Adding comments and documentation to explain the logic.

(3) Ensuring the program could handle edge cases gracefully.

Evolution of Programming Practices
--
Through this work, I improved my ability to write programs that are:

Maintainable: Code is modular and well-documented, making it easier to update or extend in the future.

Readable: Variables, functions, and logic are clearly named and structured.

Adaptable: The code can handle additional features, such as alternative data structures, with minimal changes.

This experience has reinforced the importance of thoughtful design and analysis in creating efficient and scalable software solutions.

Conclusion
--
These projects have solidified my understanding of data structures and algorithms, their applications, and their impact on software performance. The insights gained will guide me in future programming tasks, ensuring I approach problems with efficiency, clarity, and scalability in mind.

